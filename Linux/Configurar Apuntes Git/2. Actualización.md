Tenemos ya creado el repositorio y lo hemos subido, ahora para entender mejor como funciona y sus conceptos acabamos de realizar unos cambios en obsidian los cuales queremos subir, a cargar nuestros archivos y modificaciones a `staging area` 
```
git add .
```
![[Pasted image 20240919101326.png]]

Ahora los subimos a nuestro `repositorio local`
```
git commit -m "Actualización"
```
![[Pasted image 20240919101604.png]]

Si trabajasemos con mas ordenadores primero tendriamos que ejecutar un `pull`para descargar los archivos, este comando combina dos acciones
1. **git fetch:** Descarga los cambios más recientes del repositorio remoto, pero no los aplica automáticamente.
2. **git merge**: Fusiona esos cambios con los que tienes localmente.
```
git pull Mis-Apuntes main
```

Y ahora realizariamos la subida a la nube de github
```
git push Mis-Apuntes main
```
![[Pasted image 20240919101842.png]]

Ahora si queremos ver el historial de cambios ejecutamos el siguiente comando
```
git log
```
![[Pasted image 20240919102132.png]]
![[Pasted image 20240919102116.png]]

Después de esta ultima subida si volvemos a github podremos ver las carpetas actualizadas
![[Pasted image 20240919102441.png]]

Cuando vayas a realizar cambios y quieras ejecutar `pull` antes tendremos que configurarlo, para ello tenemos estas tres opciones
1. `git config pull.rebase false` **(fusionar)**: Mantiene los commits locales y remotos separados, combinándolos en un solo commit de “merge”. Útil si no te importa tener un historial de commits más complejo.
2. `git config pull.rebase true` **(rebase)**: Mantiene un historial de commits más limpio, reordenando los commits locales para que se apliquen después de los remotos.
3. `git config pull.ff only` **(fast-forward)**: Solo permite actualizaciones si no hay divergencias. Es la opción más segura si no deseas lidiar con fusiones o rebase, pero podría fallar si las ramas ya han divergido.